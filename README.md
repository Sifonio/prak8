Задання №1

![image](https://github.com/user-attachments/assets/a8b8eb42-bc56-4b0c-b529-d920af5ddb96)

Так, виклик count = write(fd, buffer, nbytes) може повернути значення відмінне від nbytes і це означає, що було записано менше байтів ніж запитувалося 

Задання №2

![image](https://github.com/user-attachments/assets/72006189-3e58-4cfc-8c1e-10edcbf5f7fd)

Задання №3

![image](https://github.com/user-attachments/assets/987fc3ac-7721-4550-a4e4-ea3925560b80)

Задання №4

![image](https://github.com/user-attachments/assets/5bf16a36-f374-4136-a5de-5ff70770f0a6)

Коли виконується fork(), програма розділяється на два процеси. Один — це батьківський, а другий — новий, дочірній. У батьківському процесі fork() повертає номер дочірнього процесу (якеcь додатне число). У дочірньому процесі fork() повертає 0. Обидва процеси далі виконують одну і ту саму програму і обидва виводять на екран значення pid. Тому на екрані ми побачимо два числа: одне — 0 (від дочірнього процесу), друге — номер дочірнього процесу (від батьківського)

Задання №5

У дочірньому процесі ми перенаправили стандартний ввід на кінець pipe для читання (arr[0]), але забули закрити кінець для запису (arr[1]). Коли батьківський процес завершує запис і закриває свій дескриптор для запису, він очікує, що дочірній процес отримає кінець потоку (EOF). Проте, оскільки у дочірнього процесу все ще відкритий дескриптор для запису, pipe залишається активним і кінець потоку не настає. В результаті команда wc -l, яка читає зі стандартного вводу, продовжує чекати на дані і не завершується, оскільки вона не бачить EOF. Це призводить до зависання програми.
